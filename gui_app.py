"""
Line Analyzer GUI Application
=============================
–°–æ–≤—Ä–µ–º–µ–Ω–Ω—ã–π –≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –æ—Ç–Ω–æ—à–µ–Ω–∏–π –º–µ–∂–¥—É –ª–∏–Ω–∏—è–º–∏
–ò—Å–ø–æ–ª—å–∑—É–µ—Ç CustomTkinter –¥–ª—è —Å–æ–≤—Ä–µ–º–µ–Ω–Ω–æ–≥–æ –≤–Ω–µ—à–Ω–µ–≥–æ –≤–∏–¥–∞
"""

import customtkinter as ctk
from tkinter import messagebox
from typing import List, Dict, Any
from line_geometry import Line, analyze_all_lines
import sys
import random
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np


class LineAnalyzerApp(ctk.CTk):
    """–ì–ª–∞–≤–Ω–æ–µ –æ–∫–Ω–æ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è –¥–ª—è –∞–Ω–∞–ª–∏–∑–∞ –ª–∏–Ω–∏–π"""
    
    def __init__(self):
        super().__init__()
        
        # –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–∫–Ω–∞
        self.title("Line Relationship Analyzer")
        
        # –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–º—É (dark/light)
        ctk.set_appearance_mode("light")
        ctk.set_default_color_theme("blue")
        
        # –ü–æ–ª—É—á–∞–µ–º —Ä–∞–∑–º–µ—Ä —ç–∫—Ä–∞–Ω–∞ –∏ —É—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º –æ–∫–Ω–æ –Ω–∞ –≤–µ—Å—å —ç–∫—Ä–∞–Ω
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        self.geometry(f"{screen_width}x{screen_height}+0+0")
        
        # –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ
        self.num_lines = 0
        self.line_entries: List[Dict[str, ctk.CTkEntry]] = []
        
        # –°–æ–∑–¥–∞–µ–º –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å
        self.create_widgets()
    
    def center_window(self):
        """–¶–µ–Ω—Ç—Ä–∏—Ä—É–µ—Ç –æ–∫–Ω–æ –Ω–∞ —ç–∫—Ä–∞–Ω–µ"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f'{width}x{height}+{x}+{y}')
    
    def create_widgets(self):
        """–°–æ–∑–¥–∞–µ—Ç –≤—Å–µ –≤–∏–¥–∂–µ—Ç—ã –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å–∞"""
        
        # –ó–∞–≥–æ–ª–æ–≤–æ–∫
        title_label = ctk.CTkLabel(
            self,
            text="üìê Line Relationship Analyzer",
            font=ctk.CTkFont(size=20, weight="bold")
        )
        title_label.pack(pady=15)
        
        subtitle_label = ctk.CTkLabel(
            self,
            text="Analyze relationships between lines in general form: Ax + By + C = 0",
            font=ctk.CTkFont(size=11)
        )
        subtitle_label.pack(pady=(0, 15))
        
        # –û—Å–Ω–æ–≤–Ω–æ–π –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä - –¥–≤–µ –∫–æ–ª–æ–Ω–∫–∏
        main_container = ctk.CTkFrame(self, fg_color="transparent")
        main_container.pack(fill="both", expand=True, padx=20, pady=10)
        
        # –õ–µ–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞ (–≤–≤–æ–¥ –¥–∞–Ω–Ω—ã—Ö)
        left_column = ctk.CTkFrame(main_container, fg_color="#E8E8E8", corner_radius=10)
        left_column.pack(side="left", fill="both", expand=True, padx=(0, 10))
        
        # –ü—Ä–∞–≤–∞—è –∫–æ–ª–æ–Ω–∫–∞ (–≥—Ä–∞—Ñ–∏–∫)
        right_column = ctk.CTkFrame(main_container, fg_color="#FFFFFF", corner_radius=10)
        right_column.pack(side="right", fill="both", expand=True, padx=(10, 0))
        
        # === –õ–ï–í–ê–Ø –ö–û–õ–û–ù–ö–ê: –í–≤–æ–¥ –¥–∞–Ω–Ω—ã—Ö ===
        
        # –°–µ–∫—Ü–∏—è –≤–≤–æ–¥–∞ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ –ª–∏–Ω–∏–π
        input_frame = ctk.CTkFrame(left_column, fg_color="transparent")
        input_frame.pack(fill="x", pady=15, padx=15)
        
        num_lines_label = ctk.CTkLabel(
            input_frame,
            text="Number of lines (n ‚â• 2):",
            font=ctk.CTkFont(size=13, weight="bold")
        )
        num_lines_label.pack(pady=(0, 10))
        
        input_container = ctk.CTkFrame(input_frame, fg_color="transparent")
        input_container.pack(pady=5)
        
        self.num_lines_entry = ctk.CTkEntry(
            input_container,
            width=80,
            placeholder_text="e.g., 3"
        )
        self.num_lines_entry.pack(side="left", padx=5)
        
        generate_button = ctk.CTkButton(
            input_container,
            text="Generate Input Fields",
            command=self.generate_line_inputs,
            width=150
        )
        generate_button.pack(side="left", padx=5)
        
        random_button = ctk.CTkButton(
            input_container,
            text="üé≤ Random",
            command=self.fill_random_values,
            width=100,
            fg_color="#9B59B6",
            hover_color="#8E44AD"
        )
        random_button.pack(side="left", padx=5)
        
        # –°–µ–∫—Ü–∏—è –ø–æ–ª–µ–π –≤–≤–æ–¥–∞ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ (—Å –ø—Ä–æ–∫—Ä—É—Ç–∫–æ–π)
        self.lines_frame = ctk.CTkScrollableFrame(left_column, fg_color="transparent", height=250)
        self.lines_frame.pack(fill="both", expand=True, pady=10, padx=15)
        
        # –ö–Ω–æ–ø–∫–∏ –¥–µ–π—Å—Ç–≤–∏–π
        actions_frame = ctk.CTkFrame(left_column, fg_color="transparent")
        actions_frame.pack(fill="x", pady=10, padx=15)
        
        analyze_button = ctk.CTkButton(
            actions_frame,
            text="üîç Analyze Lines",
            command=self.analyze_lines,
            font=ctk.CTkFont(size=13, weight="bold"),
            height=40,
            fg_color="#2CC985",
            hover_color="#25A56C"
        )
        analyze_button.pack(fill="x", pady=2)
        
        clear_button = ctk.CTkButton(
            actions_frame,
            text="üóëÔ∏è Clear",
            command=self.clear_all,
            font=ctk.CTkFont(size=13, weight="bold"),
            height=40,
            fg_color="#E74C3C",
            hover_color="#C0392B"
        )
        clear_button.pack(fill="x", pady=2)
        
        visualize_button = ctk.CTkButton(
            actions_frame,
            text="üìä Visualize",
            command=self.visualize_lines,
            font=ctk.CTkFont(size=13, weight="bold"),
            height=40,
            fg_color="#3498DB",
            hover_color="#2980B9"
        )
        visualize_button.pack(fill="x", pady=2)
        
        source_button = ctk.CTkButton(
            actions_frame,
            text="üìÑ View Source Code",
            command=self.view_source_code,
            font=ctk.CTkFont(size=13, weight="bold"),
            height=40,
            fg_color="#95A5A6",
            hover_color="#7F8C8D"
        )
        source_button.pack(fill="x", pady=2)
        
        # –°–µ–∫—Ü–∏—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
        results_label = ctk.CTkLabel(
            left_column,
            text="üìä Analysis Results",
            font=ctk.CTkFont(size=14, weight="bold")
        )
        results_label.pack(pady=(10, 5), padx=15)
        
        self.results_text = ctk.CTkTextbox(
            left_column,
            height=500,
            font=ctk.CTkFont(family="Consolas", size=10)
        )
        self.results_text.pack(fill="both", expand=True, pady=(0, 15), padx=15)
        
        # –ò–∑–Ω–∞—á–∞–ª—å–Ω–æ –æ—Ç–∫–ª—é—á–∞–µ–º —Ç–µ–∫—Å—Ç–æ–≤–æ–µ –ø–æ–ª–µ –¥–ª—è —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è
        self.results_text.configure(state="disabled")
        
        # === –ü–†–ê–í–ê–Ø –ö–û–õ–û–ù–ö–ê: –ì—Ä–∞—Ñ–∏–∫ ===
        
        graph_title = ctk.CTkLabel(
            right_column,
            text="The Graph",
            font=ctk.CTkFont(size=18, weight="bold")
        )
        graph_title.pack(pady=20)
        
        # –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞
        self.graph_frame = ctk.CTkFrame(right_column, fg_color="#F5F5F5")
        self.graph_frame.pack(fill="both", expand=True, padx=20, pady=(0, 20))
        
        # Placeholder
        self.graph_placeholder = ctk.CTkLabel(
            self.graph_frame,
            text="Press 'Visualize' to display the graph",
            font=ctk.CTkFont(size=12),
            text_color="gray"
        )
        self.graph_placeholder.pack(expand=True)
        
        # Canvas –¥–ª—è matplotlib (–±—É–¥–µ—Ç —Å–æ–∑–¥–∞–Ω –ø—Ä–∏ –≤–∏–∑—É–∞–ª–∏–∑–∞—Ü–∏–∏)
        self.canvas_widget = None
        
        # –°—Ç–∞—Ç—É—Å –±–∞—Ä
        self.status_label = ctk.CTkLabel(
            self,
            text="Ready",
            font=ctk.CTkFont(size=10),
            text_color="gray"
        )
        self.status_label.pack(side="bottom", pady=5)
    
    def generate_line_inputs(self):
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø–æ–ª—è –≤–≤–æ–¥–∞ –¥–ª—è –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ –ª–∏–Ω–∏–π"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –ª–∏–Ω–∏–π
            n = int(self.num_lines_entry.get())
            
            # –í–∞–ª–∏–¥–∞—Ü–∏—è
            if n < 2:
                messagebox.showerror(
                    "Invalid Input",
                    "Number of lines must be at least 2!\n\nPlease enter n ‚â• 2."
                )
                return
            
            if n > 10:
                response = messagebox.askyesno(
                    "Large Number of Lines",
                    f"You entered {n} lines. This will create {n*(n-1)//2} pairs to analyze.\n\nContinue?"
                )
                if not response:
                    return
            
            # –û—á–∏—â–∞–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –ø–æ–ª—è
            for widget in self.lines_frame.winfo_children():
                widget.destroy()
            self.line_entries.clear()
            
            # –ó–∞–≥–æ–ª–æ–≤–æ–∫
            header = ctk.CTkLabel(
                self.lines_frame,
                text="Enter coefficients for each line:",
                font=ctk.CTkFont(size=14, weight="bold")
            )
            header.pack(pady=10)
            
            # –°–æ–∑–¥–∞–µ–º –ø–æ–ª—è –¥–ª—è –∫–∞–∂–¥–æ–π –ª–∏–Ω–∏–∏
            for i in range(n):
                line_container = ctk.CTkFrame(self.lines_frame)
                line_container.pack(fill="x", pady=5, padx=10)
                
                # –ú–µ—Ç–∫–∞ –ª–∏–Ω–∏–∏
                line_label = ctk.CTkLabel(
                    line_container,
                    text=f"Line {i+1}:",
                    font=ctk.CTkFont(size=12, weight="bold"),
                    width=60
                )
                line_label.pack(side="left", padx=5)
                
                # –ü–æ–ª–µ A
                a_label = ctk.CTkLabel(line_container, text="A:", width=20)
                a_label.pack(side="left", padx=2)
                a_entry = ctk.CTkEntry(line_container, width=80, placeholder_text="0")
                a_entry.pack(side="left", padx=5)
                
                # –ü–æ–ª–µ B
                b_label = ctk.CTkLabel(line_container, text="B:", width=20)
                b_label.pack(side="left", padx=2)
                b_entry = ctk.CTkEntry(line_container, width=80, placeholder_text="0")
                b_entry.pack(side="left", padx=5)
                
                # –ü–æ–ª–µ C
                c_label = ctk.CTkLabel(line_container, text="C:", width=20)
                c_label.pack(side="left", padx=2)
                c_entry = ctk.CTkEntry(line_container, width=80, placeholder_text="0")
                c_entry.pack(side="left", padx=5)
                
                # –£—Ä–∞–≤–Ω–µ–Ω–∏–µ
                equation_label = ctk.CTkLabel(
                    line_container,
                    text="‚Üí  Ax + By + C = 0",
                    font=ctk.CTkFont(size=10),
                    text_color="gray"
                )
                equation_label.pack(side="left", padx=10)
                
                # –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Å—ã–ª–∫–∏ –Ω–∞ –ø–æ–ª—è
                self.line_entries.append({
                    'A': a_entry,
                    'B': b_entry,
                    'C': c_entry
                })
            
            self.num_lines = n
            self.update_status(f"Generated {n} input fields")
            
        except ValueError:
            messagebox.showerror(
                "Invalid Input",
                "Please enter a valid integer for the number of lines."
            )
    
    def analyze_lines(self):
        """–ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ—Ç –≤—Å–µ –≤–≤–µ–¥–µ–Ω–Ω—ã–µ –ª–∏–Ω–∏–∏"""
        if not self.line_entries:
            messagebox.showwarning(
                "No Lines",
                "Please generate input fields first!"
            )
            return
        
        try:
            # –°–æ–±–∏—Ä–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –ø–æ–ª–µ–π –≤–≤–æ–¥–∞
            lines = []
            for i, entry_dict in enumerate(self.line_entries):
                try:
                    A = float(entry_dict['A'].get() or 0)
                    B = float(entry_dict['B'].get() or 0)
                    C = float(entry_dict['C'].get() or 0)
                    
                    line = Line(A, B, C)
                    lines.append(line)
                    
                except ValueError as e:
                    if "Invalid line" in str(e):
                        messagebox.showerror(
                            "Invalid Line",
                            f"Line {i+1} is invalid!\n\n"
                            f"Both A and B cannot be zero.\n"
                            f"A line must be well-defined: (A, B) ‚â† (0, 0)"
                        )
                        return
                    else:
                        messagebox.showerror(
                            "Invalid Input",
                            f"Error in Line {i+1}:\n{str(e)}\n\n"
                            f"Please enter valid numbers for A, B, and C."
                        )
                        return
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –≤—Å–µ –ø–∞—Ä—ã
            results = analyze_all_lines(lines)
            
            # –û—Ç–æ–±—Ä–∞–∂–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            self.display_results(results)
            self.update_status(f"Analyzed {len(lines)} lines, found {len(results)} pairs")
            
        except Exception as e:
            messagebox.showerror(
                "Error",
                f"An error occurred during analysis:\n\n{str(e)}"
            )
    
    def display_results(self, results: List[Dict[str, Any]]):
        """–û—Ç–æ–±—Ä–∞–∂–∞–µ—Ç —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã –∞–Ω–∞–ª–∏–∑–∞ —Å –ø–æ–¥—Ä–æ–±–Ω—ã–º–∏ —à–∞–≥–∞–º–∏ —Ä–µ—à–µ–Ω–∏—è"""
        self.results_text.configure(state="normal")
        self.results_text.delete("1.0", "end")
        
        # –ó–∞–≥–æ–ª–æ–≤–æ–∫
        header = "‚ïî" + "‚ïê" * 78 + "‚ïó\n"
        header += "‚ïë" + " " * 25 + "ANALYSIS RESULTS" + " " * 37 + "‚ïë\n"
        header += "‚ïö" + "‚ïê" * 78 + "‚ïù\n\n"
        self.results_text.insert("end", header)
        
        if not results:
            self.results_text.insert("end", "No line pairs to analyze.\n")
            self.results_text.configure(state="disabled")
            return
        
        # –í—ã–≤–æ–¥–∏–º –∫–∞–∂–¥—É—é –ø–∞—Ä—É
        for i, result in enumerate(results, 1):
            line1 = result['line1']
            line2 = result['line2']
            pair = result['pair']
            relation = result['relation']
            intersection = result['intersection']
            angle = result['angle']
            
            # –ó–∞–≥–æ–ª–æ–≤–æ–∫ –ø–∞—Ä—ã
            pair_header = f"‚îå‚îÄ Pair {i}: Line {pair[0]} and Line {pair[1]} " + "‚îÄ" * (54 - len(str(i))) + "‚îê\n"
            self.results_text.insert("end", pair_header)
            
            # –£—Ä–∞–≤–Ω–µ–Ω–∏—è –ª–∏–Ω–∏–π
            self.results_text.insert("end", f"‚îÇ\n")
            self.results_text.insert("end", f"‚îÇ Given lines:\n")
            self.results_text.insert("end", f"‚îÇ   L{pair[0]}: {line1.A}x + {line1.B}y + {line1.C} = 0\n")
            self.results_text.insert("end", f"‚îÇ   L{pair[1]}: {line2.A}x + {line2.B}y + {line2.C} = 0\n")
            self.results_text.insert("end", f"‚îÇ\n")
            
            # –®–ê–ì 1: –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø—Ä–æ–ø–æ—Ä—Ü–∏–æ–Ω–∞–ª—å–Ω–æ—Å—Ç–∏
            self.results_text.insert("end", f"‚îÇ STEP 1: Check proportionality of coefficients\n")
            self.results_text.insert("end", f"‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n")
            
            A1, B1, C1 = line1.A, line1.B, line1.C
            A2, B2, C2 = line2.A, line2.B, line2.C
            
            # –í—ã—á–∏—Å–ª—è–µ–º –æ—Ç–Ω–æ—à–µ–Ω–∏—è –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤
            self.results_text.insert("end", f"‚îÇ   Check ratios:\n")
            if A2 != 0:
                self.results_text.insert("end", f"‚îÇ     A‚ÇÅ/A‚ÇÇ = {A1}/{A2} = {A1/A2:.4f}\n")
            else:
                self.results_text.insert("end", f"‚îÇ     A‚ÇÅ/A‚ÇÇ = {A1}/{A2} = ‚àû (A‚ÇÇ=0)\n")
            
            if B2 != 0:
                self.results_text.insert("end", f"‚îÇ     B‚ÇÅ/B‚ÇÇ = {B1}/{B2} = {B1/B2:.4f}\n")
            else:
                self.results_text.insert("end", f"‚îÇ     B‚ÇÅ/B‚ÇÇ = {B1}/{B2} = ‚àû (B‚ÇÇ=0)\n")
            
            if C2 != 0:
                self.results_text.insert("end", f"‚îÇ     C‚ÇÅ/C‚ÇÇ = {C1}/{C2} = {C1/C2:.4f}\n")
            else:
                self.results_text.insert("end", f"‚îÇ     C‚ÇÅ/C‚ÇÇ = {C1}/{C2} = ‚àû (C‚ÇÇ=0)\n")
            
            self.results_text.insert("end", f"‚îÇ\n")
            
            # –®–ê–ì 2: –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –æ—Ç–Ω–æ—à–µ–Ω–∏—è
            self.results_text.insert("end", f"‚îÇ STEP 2: Determine relationship\n")
            self.results_text.insert("end", f"‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n")
            
            if relation == "coincident":
                self.results_text.insert("end", f"‚îÇ   A‚ÇÅ/A‚ÇÇ = B‚ÇÅ/B‚ÇÇ = C‚ÇÅ/C‚ÇÇ  ‚Üí  Lines COINCIDE\n")
                self.results_text.insert("end", f"‚îÇ   ‚â° The lines are identical (same line)\n")
            elif relation == "parallel":
                self.results_text.insert("end", f"‚îÇ   A‚ÇÅ/A‚ÇÇ = B‚ÇÅ/B‚ÇÇ ‚â† C‚ÇÅ/C‚ÇÇ  ‚Üí  Lines are PARALLEL\n")
                self.results_text.insert("end", f"‚îÇ   ‚ïë The lines never intersect\n")
            else:  # intersect
                self.results_text.insert("end", f"‚îÇ   A‚ÇÅ/A‚ÇÇ ‚â† B‚ÇÅ/B‚ÇÇ  ‚Üí  Lines INTERSECT\n")
                self.results_text.insert("end", f"‚îÇ   ‚úì The lines meet at one point\n")
            
            self.results_text.insert("end", f"‚îÇ\n")
            
            # –®–ê–ì 3: –¢–æ—á–∫–∞ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è (–µ—Å–ª–∏ –µ—Å—Ç—å)
            if intersection:
                x, y = intersection
                self.results_text.insert("end", f"‚îÇ STEP 3: Find intersection point (Cramer's Rule)\n")
                self.results_text.insert("end", f"‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n")
                self.results_text.insert("end", f"‚îÇ   System of equations:\n")
                self.results_text.insert("end", f"‚îÇ     {A1}x + {B1}y = {-C1}\n")
                self.results_text.insert("end", f"‚îÇ     {A2}x + {B2}y = {-C2}\n")
                self.results_text.insert("end", f"‚îÇ\n")
                
                # –î–µ—Ç–µ—Ä–º–∏–Ω–∞–Ω—Ç—ã
                det = A1 * B2 - A2 * B1
                det_x = (-C1) * B2 - (-C2) * B1
                det_y = A1 * (-C2) - A2 * (-C1)
                
                self.results_text.insert("end", f"‚îÇ   Calculate determinants:\n")
                self.results_text.insert("end", f"‚îÇ     D = ‚îÇ{A1:6.1f} {B1:6.1f}‚îÇ = {A1}√ó{B2} - {A2}√ó{B1} = {det:.4f}\n")
                self.results_text.insert("end", f"‚îÇ         ‚îÇ{A2:6.1f} {B2:6.1f}‚îÇ\n")
                self.results_text.insert("end", f"‚îÇ\n")
                self.results_text.insert("end", f"‚îÇ     D‚Çì = ‚îÇ{-C1:6.1f} {B1:6.1f}‚îÇ = {det_x:.4f}\n")
                self.results_text.insert("end", f"‚îÇ          ‚îÇ{-C2:6.1f} {B2:6.1f}‚îÇ\n")
                self.results_text.insert("end", f"‚îÇ\n")
                self.results_text.insert("end", f"‚îÇ     D·µß = ‚îÇ{A1:6.1f} {-C1:6.1f}‚îÇ = {det_y:.4f}\n")
                self.results_text.insert("end", f"‚îÇ          ‚îÇ{A2:6.1f} {-C2:6.1f}‚îÇ\n")
                self.results_text.insert("end", f"‚îÇ\n")
                self.results_text.insert("end", f"‚îÇ   Solution:\n")
                self.results_text.insert("end", f"‚îÇ     x = D‚Çì/D = {det_x:.4f}/{det:.4f} = {x:.4f}\n")
                self.results_text.insert("end", f"‚îÇ     y = D·µß/D = {det_y:.4f}/{det:.4f} = {y:.4f}\n")
                self.results_text.insert("end", f"‚îÇ\n")
                self.results_text.insert("end", f"‚îÇ   ‚òÖ Intersection point: P = ({x:.4f}, {y:.4f})\n")
                self.results_text.insert("end", f"‚îÇ\n")
            
            # –®–ê–ì 4: –£–≥–æ–ª –º–µ–∂–¥—É –ª–∏–Ω–∏—è–º–∏ (–µ—Å–ª–∏ –µ—Å—Ç—å)
            if angle is not None:
                self.results_text.insert("end", f"‚îÇ STEP 4: Calculate angle between lines\n")
                self.results_text.insert("end", f"‚îÇ ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n")
                
                # –í—ã—á–∏—Å–ª—è–µ–º –Ω–∞–∫–ª–æ–Ω—ã
                if line1.B != 0 and line2.B != 0:
                    m1 = -line1.A / line1.B
                    m2 = -line2.A / line2.B
                    self.results_text.insert("end", f"‚îÇ   Slopes:\n")
                    self.results_text.insert("end", f"‚îÇ     m‚ÇÅ = -A‚ÇÅ/B‚ÇÅ = -{A1}/{B1} = {m1:.4f}\n")
                    self.results_text.insert("end", f"‚îÇ     m‚ÇÇ = -A‚ÇÇ/B‚ÇÇ = -{A2}/{B2} = {m2:.4f}\n")
                    self.results_text.insert("end", f"‚îÇ\n")
                    
                    if abs(1 + m1 * m2) > 1e-10:
                        tan_theta = abs((m2 - m1) / (1 + m1 * m2))
                        self.results_text.insert("end", f"‚îÇ   Angle formula:\n")
                        self.results_text.insert("end", f"‚îÇ     tan(Œ∏) = |m‚ÇÇ - m‚ÇÅ| / |1 + m‚ÇÅ√óm‚ÇÇ|\n")
                        self.results_text.insert("end", f"‚îÇ     tan(Œ∏) = |{m2:.4f} - {m1:.4f}| / |1 + {m1:.4f}√ó{m2:.4f}|\n")
                        self.results_text.insert("end", f"‚îÇ     tan(Œ∏) = {tan_theta:.4f}\n")
                        self.results_text.insert("end", f"‚îÇ     Œ∏ = arctan({tan_theta:.4f}) = {angle:.2f}¬∞\n")
                    else:
                        self.results_text.insert("end", f"‚îÇ   Lines are perpendicular (m‚ÇÅ√óm‚ÇÇ = -1)\n")
                        self.results_text.insert("end", f"‚îÇ     Œ∏ = 90.00¬∞\n")
                else:
                    self.results_text.insert("end", f"‚îÇ   One line is vertical (B = 0)\n")
                    self.results_text.insert("end", f"‚îÇ     Œ∏ = {angle:.2f}¬∞\n")
                
                self.results_text.insert("end", f"‚îÇ\n")
                self.results_text.insert("end", f"‚îÇ   ‚òÖ Angle: Œ∏ = {angle:.2f}¬∞\n")
                self.results_text.insert("end", f"‚îÇ\n")
            
            # –ò—Ç–æ–≥–∏ –¥–ª—è –ø–∞—Ä—ã
            self.results_text.insert("end", f"‚îÇ CONCLUSION:\n")
            if relation == "intersect":
                self.results_text.insert("end", f"‚îÇ   ‚úì Lines intersect at ({intersection[0]:.4f}, {intersection[1]:.4f})\n")
                self.results_text.insert("end", f"‚îÇ   ‚úì Angle between lines: {angle:.2f}¬∞\n")
            elif relation == "parallel":
                self.results_text.insert("end", f"‚îÇ   ‚ïë Lines are parallel and distinct\n")
            else:
                self.results_text.insert("end", f"‚îÇ   ‚â° Lines coincide (same line)\n")
            
            self.results_text.insert("end", f"‚îî" + "‚îÄ" * 78 + "‚îò\n\n")
        
        # –û–±—â–∞—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
        summary = "‚ïî" + "‚ïê" * 78 + "‚ïó\n"
        summary += "‚ïë" + " " * 30 + "SUMMARY" + " " * 41 + "‚ïë\n"
        summary += "‚ïö" + "‚ïê" * 78 + "‚ïù\n"
        
        # –ü–æ–¥—Å—á–µ—Ç —Ç–∏–ø–æ–≤ –æ—Ç–Ω–æ—à–µ–Ω–∏–π
        intersect_count = sum(1 for r in results if r['relation'] == 'intersect')
        parallel_count = sum(1 for r in results if r['relation'] == 'parallel')
        coincident_count = sum(1 for r in results if r['relation'] == 'coincident')
        
        summary += f"\nTotal pairs analyzed: {len(results)}\n"
        summary += f"  ‚úì Intersecting pairs: {intersect_count}\n"
        summary += f"  ‚ïë Parallel pairs: {parallel_count}\n"
        summary += f"  ‚â° Coincident pairs: {coincident_count}\n"
        
        self.results_text.insert("end", summary)
        
        self.results_text.configure(state="disabled")
    
    def visualize_lines(self):
        """–í–∏–∑—É–∞–ª–∏–∑–∏—Ä—É–µ—Ç –ª–∏–Ω–∏–∏ –Ω–∞ –≥—Ä–∞—Ñ–∏–∫–µ –≤–Ω—É—Ç—Ä–∏ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è"""
        if not self.line_entries:
            messagebox.showwarning(
                "No Lines",
                "Please generate input fields first!"
            )
            return
        
        try:
            # –°–æ–±–∏—Ä–∞–µ–º –ª–∏–Ω–∏–∏
            lines = []
            for i, entry_dict in enumerate(self.line_entries):
                try:
                    A = float(entry_dict['A'].get() or 0)
                    B = float(entry_dict['B'].get() or 0)
                    C = float(entry_dict['C'].get() or 0)
                    
                    line = Line(A, B, C)
                    lines.append(line)
                    
                except ValueError as e:
                    if "Invalid line" in str(e):
                        messagebox.showerror(
                            "Invalid Line",
                            f"Line {i+1} is invalid!\n\n"
                            f"Both A and B cannot be zero."
                        )
                        return
                    else:
                        messagebox.showerror(
                            "Invalid Input",
                            f"Error in Line {i+1}. Please enter valid numbers."
                        )
                        return
            
            # –£–¥–∞–ª—è–µ–º —Å—Ç–∞—Ä—ã–π canvas –µ—Å–ª–∏ –µ—Å—Ç—å
            if self.canvas_widget:
                self.canvas_widget.get_tk_widget().destroy()
            
            # –°–∫—Ä—ã–≤–∞–µ–º placeholder
            self.graph_placeholder.pack_forget()
            
            # –°–æ–∑–¥–∞–µ–º –≥—Ä–∞—Ñ–∏–∫
            fig, ax = plt.subplots(figsize=(6, 5), dpi=100)
            
            # –û–ø—Ä–µ–¥–µ–ª—è–µ–º –¥–∏–∞–ø–∞–∑–æ–Ω –¥–ª—è –≥—Ä–∞—Ñ–∏–∫–∞
            x_range = np.linspace(-10, 10, 400)
            
            # –¶–≤–µ—Ç–∞ –¥–ª—è –ª–∏–Ω–∏–π
            colors = plt.cm.tab10(np.linspace(0, 1, len(lines)))
            
            # –†–∏—Å—É–µ–º –∫–∞–∂–¥—É—é –ª–∏–Ω–∏—é
            for idx, line in enumerate(lines):
                if line.B != 0:
                    # –û–±—ã—á–Ω–∞—è –ª–∏–Ω–∏—è: y = -(A*x + C) / B
                    y = -(line.A * x_range + line.C) / line.B
                    ax.plot(x_range, y, label=f'Line {idx+1}: {line}', 
                           color=colors[idx], linewidth=2)
                else:
                    # –í–µ—Ä—Ç–∏–∫–∞–ª—å–Ω–∞—è –ª–∏–Ω–∏—è: x = -C/A
                    x_val = -line.C / line.A
                    ax.axvline(x=x_val, label=f'Line {idx+1}: {line}', 
                              color=colors[idx], linewidth=2)
            
            # –ù–∞—Ö–æ–¥–∏–º –∏ –æ—Ç–º–µ—á–∞–µ–º —Ç–æ—á–∫–∏ –ø–µ—Ä–µ—Å–µ—á–µ–Ω–∏—è
            from line_geometry import find_intersection, get_line_relation
            for i in range(len(lines)):
                for j in range(i+1, len(lines)):
                    relation = get_line_relation(lines[i], lines[j])
                    if relation == "intersect":
                        point = find_intersection(lines[i], lines[j])
                        if point:
                            x, y = point
                            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —Ç–æ—á–∫–∞ –≤ –≤–∏–¥–∏–º–æ–º –¥–∏–∞–ø–∞–∑–æ–Ω–µ
                            if -10 <= x <= 10 and -10 <= y <= 10:
                                ax.plot(x, y, 'ro', markersize=8, zorder=5)
                                ax.annotate(f'({x:.1f}, {y:.1f})', 
                                          xy=(x, y), xytext=(5, 5),
                                          textcoords='offset points',
                                          fontsize=8,
                                          bbox=dict(boxstyle='round,pad=0.3', 
                                                  facecolor='yellow', alpha=0.7))
            
            # –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –≥—Ä–∞—Ñ–∏–∫–∞
            ax.set_xlim(-10, 10)
            ax.set_ylim(-10, 10)
            ax.grid(True, alpha=0.3)
            ax.axhline(y=0, color='k', linewidth=0.5)
            ax.axvline(x=0, color='k', linewidth=0.5)
            ax.set_xlabel('X', fontsize=10)
            ax.set_ylabel('Y', fontsize=10)
            ax.set_title('Line Visualization', fontsize=12, fontweight='bold')
            ax.legend(loc='upper right', fontsize=8)
            
            # –í—Å—Ç—Ä–∞–∏–≤–∞–µ–º –≥—Ä–∞—Ñ–∏–∫ –≤ tkinter
            self.canvas_widget = FigureCanvasTkAgg(fig, master=self.graph_frame)
            self.canvas_widget.draw()
            self.canvas_widget.get_tk_widget().pack(fill="both", expand=True)
            
            self.update_status(f"Visualized {len(lines)} lines")
            
        except Exception as e:
            messagebox.showerror(
                "Error",
                f"An error occurred during visualization:\n\n{str(e)}"
            )
    
    def clear_all(self):
        """–û—á–∏—â–∞–µ—Ç –≤—Å–µ –ø–æ–ª—è –∏ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã"""
        # –û—á–∏—â–∞–µ–º –ø–æ–ª—è –≤–≤–æ–¥–∞
        for entry_dict in self.line_entries:
            entry_dict['A'].delete(0, 'end')
            entry_dict['B'].delete(0, 'end')
            entry_dict['C'].delete(0, 'end')
        
        # –û—á–∏—â–∞–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
        self.results_text.configure(state="normal")
        self.results_text.delete("1.0", "end")
        self.results_text.configure(state="disabled")
        
        self.update_status("Cleared all inputs and results")
    
    def fill_random_values(self):
        """–ó–∞–ø–æ–ª–Ω—è–µ—Ç –ø—É—Å—Ç—ã–µ –ø–æ–ª—è —Å–ª—É—á–∞–π–Ω—ã–º–∏ –∑–Ω–∞—á–µ–Ω–∏—è–º–∏"""
        if not self.line_entries:
            messagebox.showwarning(
                "No Input Fields",
                "Please generate input fields first!"
            )
            return
        
        filled_count = 0
        
        for entry_dict in self.line_entries:
            # –ó–∞–ø–æ–ª–Ω—è–µ–º A –µ—Å–ª–∏ –ø—É—Å—Ç–æ
            if not entry_dict['A'].get():
                entry_dict['A'].delete(0, 'end')
                entry_dict['A'].insert(0, str(random.randint(-10, 10)))
                filled_count += 1
            
            # –ó–∞–ø–æ–ª–Ω—è–µ–º B –µ—Å–ª–∏ –ø—É—Å—Ç–æ
            if not entry_dict['B'].get():
                entry_dict['B'].delete(0, 'end')
                entry_dict['B'].insert(0, str(random.randint(-10, 10)))
                filled_count += 1
            
            # –ó–∞–ø–æ–ª–Ω—è–µ–º C –µ—Å–ª–∏ –ø—É—Å—Ç–æ
            if not entry_dict['C'].get():
                entry_dict['C'].delete(0, 'end')
                entry_dict['C'].insert(0, str(random.randint(-10, 10)))
                filled_count += 1
        
        if filled_count > 0:
            self.update_status(f"Filled {filled_count} empty fields with random values")
        else:
            self.update_status("All fields are already filled")
    
    def view_source_code(self):
        """–û—Ç–∫—Ä—ã–≤–∞–µ—Ç –æ–∫–Ω–æ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± –∏—Å—Ö–æ–¥–Ω–æ–º –∫–æ–¥–µ"""
        import os
        import webbrowser
        
        # –ü–æ–ª—É—á–∞–µ–º –ø—É—Ç—å –∫ —Ç–µ–∫—É—â–µ–º—É —Ñ–∞–π–ª—É
        current_dir = os.path.dirname(os.path.abspath(__file__))
        
        # –°–æ–∑–¥–∞–µ–º –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–æ–Ω–Ω–æ–µ –æ–∫–Ω–æ
        info_window = ctk.CTkToplevel(self)
        info_window.title("Source Code Information")
        info_window.geometry("600x400")
        info_window.transient(self)
        info_window.grab_set()
        
        # –ó–∞–≥–æ–ª–æ–≤–æ–∫
        title_label = ctk.CTkLabel(
            info_window,
            text="üìÑ Source Code Information",
            font=ctk.CTkFont(size=18, weight="bold")
        )
        title_label.pack(pady=20)
        
        # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
        info_text = ctk.CTkTextbox(
            info_window,
            font=ctk.CTkFont(family="Consolas", size=11),
            wrap="word"
        )
        info_text.pack(fill="both", expand=True, padx=20, pady=10)
        
        info_content = f"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë             LINE ANALYZER - SOURCE CODE INFO            ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

Project: Analytic Geometry - Line Relationship Analyzer
Author: Nurdaulet Sovetkhan
Course: Analytic Geometry, Astana IT University
Date: October 2025

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìÅ PROJECT STRUCTURE:

Main Modules:
  ‚Ä¢ main.py           - Application entry point
  ‚Ä¢ gui_app.py        - GUI interface (CustomTkinter)
  ‚Ä¢ line_geometry.py  - Mathematical engine
  ‚Ä¢ test_line_geometry.py - Unit tests (25 tests)

Build & Documentation:
  ‚Ä¢ build_exe.py      - PyInstaller build script
  ‚Ä¢ requirements.txt  - Dependencies
  ‚Ä¢ README.md         - Full documentation
  ‚Ä¢ PROJECT_SUMMARY.md - Project report

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üîß TECHNOLOGY STACK:

‚Ä¢ Python 3.12
‚Ä¢ CustomTkinter 5.2.0+ (Modern GUI)
‚Ä¢ Matplotlib 3.7.0+ (Visualization)
‚Ä¢ NumPy 1.24.0+ (Numerical computations)
‚Ä¢ PyInstaller 6.0.0+ (Executable builder)

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìÇ SOURCE CODE LOCATION:

{current_dir}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üåê GITHUB REPOSITORY:

Repository: Analytic-Geometry-Midterm
Owner: NurdauletSovetkhan
Link: github.com/NurdauletSovetkhan/Analytic-Geometry-Midterm

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

üìä STATISTICS:

‚Ä¢ Total Lines of Code: ~2000+
‚Ä¢ Number of Functions: 30+
‚Ä¢ Files: 7 main modules

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
"""
        
        info_text.insert("1.0", info_content)
        info_text.configure(state="disabled")
        
        # –ö–Ω–æ–ø–∫–∏
        buttons_frame = ctk.CTkFrame(info_window, fg_color="transparent")
        buttons_frame.pack(pady=10)
        
        def open_folder():
            try:
                if sys.platform == 'win32':
                    os.startfile(current_dir)
                elif sys.platform == 'darwin':  # macOS
                    os.system(f'open "{current_dir}"')
                else:  # Linux
                    os.system(f'xdg-open "{current_dir}"')
                self.update_status("Opened source code folder")
            except Exception as e:
                messagebox.showerror("Error", f"Could not open folder:\n{e}")
        
        def open_github():
            try:
                webbrowser.open("https://github.com/NurdauletSovetkhan/Analytic-Geometry-Midterm")
                self.update_status("Opened GitHub repository")
            except Exception as e:
                messagebox.showerror("Error", f"Could not open browser:\n{e}")
        
        folder_btn = ctk.CTkButton(
            buttons_frame,
            text="üìÅ Open Source Folder",
            command=open_folder,
            width=180
        )
        folder_btn.pack(side="left", padx=5)
        
        github_btn = ctk.CTkButton(
            buttons_frame,
            text="üåê Open GitHub Repo",
            command=open_github,
            width=180,
            fg_color="#24292e"
        )
        github_btn.pack(side="left", padx=5)
        
        close_btn = ctk.CTkButton(
            buttons_frame,
            text="Close",
            command=info_window.destroy,
            width=100,
            fg_color="#E74C3C"
        )
        close_btn.pack(side="left", padx=5)
    
    def update_status(self, message: str):
        """–û–±–Ω–æ–≤–ª—è–µ—Ç —Å—Ç–∞—Ç—É—Å –±–∞—Ä"""
        self.status_label.configure(text=message)


def main():
    """–¢–æ—á–∫–∞ –≤—Ö–æ–¥–∞ –≤ GUI –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ"""
    app = LineAnalyzerApp()
    app.mainloop()


if __name__ == "__main__":
    main()
